// -------------------------------------------------------------------------------------------------------------------------------------
/// This is a fork from cppchecks (http://sourceforge.net/apps/mediawiki/cppcheck/index.php?title=Main_Page) test suite with a few
/// modifications. This modifications where needed to adapt it to our project structure.
/// @author Dr. Martin Ettl
/// @date   2014-04-22
// -------------------------------------------------------------------------------------------------------------------------------------

#pragma once
#ifndef SIMPLE_TESTSUITE_H
#define SIMPLE_TESTSUITE_H

// enforce posix compliance for tested code
#define _POSIX_SOURCE 1

#include <sstream>
#include <iostream>
#include <iomanip>
#include <list>
#include <map>
#include <vector>
#include <utility>
#include <stdlib.h> // need for rand_r() function

#ifndef _WIN32 //LINUX
#include <unistd.h>
using namespace std;
#elif _WIN32
#include <Windows.h>
#include <minmax.h>
#endif //_WIN32
///\brief A class to store current settings for tests
class simple_testsuite_settings
{
    public:

        simple_testsuite_settings()
            : m_OutputMode(COLORED_OUTPUT)
        {}

        simple_testsuite_settings(const simple_testsuite_settings &rhs)
        {
            m_OutputMode = rhs.m_OutputMode;
        }

        simple_testsuite_settings& operator=(const simple_testsuite_settings &rhs)
        {
            // avoid copy when self assign
            if( this != &rhs )
            {
                m_OutputMode = rhs.m_OutputMode;
            }
            return *this;
        }

        void vEnableASCIIOutput(void)
        {
            m_OutputMode = ASCII_OUTPUT;
        }
        void vEnableTXT2TagsOutput(void)
        {
            m_OutputMode = TXT2TAGS_OUTPUT;
        }
        void vEnableColoredOutput(void)
        {
            m_OutputMode = COLORED_OUTPUT;
        }

        bool bIsASCIIOutputSet(void)    const
        {
            return m_OutputMode == ASCII_OUTPUT;
        }
        bool bIsTXT2TagsOutputSet(void) const
        {
            return m_OutputMode == TXT2TAGS_OUTPUT;
        }
        bool bIsColoredOutputSet(void) const
        {
            return m_OutputMode == COLORED_OUTPUT;
        }

        static std::string strGetOptionInformationString();

    protected:

        enum EOutputMode
        {
            ASCII_OUTPUT
            , TXT2TAGS_OUTPUT
            , COLORED_OUTPUT
        };

        EOutputMode m_OutputMode;
};

/// A class to record asserts and
class simple_testsuite_assert_results
{
    public:

        simple_testsuite_assert_results(void)
        {
            m_strColorTags[RED_COLOR_BEG          ] = "\033[22;31m";
            m_strColorTags[GREEN_COLOR_BEG        ] = "\033[22;32m";
            m_strColorTags[RED_COLOR_REVERSE_BEG  ] = "\033[22;31m\33[7m";
            m_strColorTags[GREEN_COLOR_REVERSE_BEG] = "\033[22;32m\33[7m";
            m_strColorTags[COLOR_END              ] = "\033[22;39m\33[0m";
        }

        simple_testsuite_assert_results(const simple_testsuite_assert_results &rhs)
            : m_Asserts(rhs.m_Asserts)
        {
            for(size_t  i = 0; i < NUMBER_OF_COLORS ; ++i)
            {
                m_strColorTags[i] = rhs.m_strColorTags[i];
            }
        }

        ~simple_testsuite_assert_results(void) {}

        simple_testsuite_assert_results& operator=(const simple_testsuite_assert_results &rhs)
        {
            // avoid copy when self assign
            if( this != &rhs )
            {
                m_Asserts   = rhs.m_Asserts;
                for(size_t  i = 0; i < NUMBER_OF_COLORS ; ++i)
                {
                    m_strColorTags[i] = rhs.m_strColorTags[i];
                }
            }
            return *this;
        }

        // -----------------------------------------------------------------------------------------------------------
        /// Record an assert result.
        //
        /// \param strFileName   --> the associated file name
        /// \param strLineNumber --> the associated line number
        /// \param strExpected   --> the expected result as string
        /// \param strActual     --> the actual result as string
        //
        /// \return true on success, false otherwise
        // -----------------------------------------------------------------------------------------------------------
        bool bAddAssertResult(const std::string &strFileName, const unsigned int &uiLineNumber, const std::string &strExpected, const std::string &strActual)
        {
            SAssertResults Item;
            std::ostringstream strStream;
            strStream << uiLineNumber;
            std::string strLineNumber(strStream.str());
            Item.strFileName   = strFileName;
            Item.strLineNumber = strLineNumber;
            Item.strExpected   = strExpected;
            Item.strActual     = strActual;
            const size_t Size  = m_Asserts.size();
            m_Asserts.push_back(Item);
            // did the push back work?
            return (Size + 1 == m_Asserts.size());
        }

        std::string strGetResults(const bool &bColorize = true)
        {
            std::string strResult("\n");
            for(std::vector<SAssertResults>::const_iterator It = m_Asserts.begin(); It != m_Asserts.end(); ++It)
            {
                if(bColorize)
                {
                    std::string strColoredExpected, strColoredActual;
                    vColourize(strColoredExpected, strColoredActual, It->strExpected, It->strActual);
                    strResult += "Assertion failed in " + It->strFileName + " at line " + It->strLineNumber + "\n";
                    strResult += "Expected:\n" + strColoredExpected + "\n";
                    strResult += "Actual:\n" + strColoredActual + "\n";
                }
                else // no color output
                {
                    strResult += "Assertion failed in " + It->strFileName + " at line " + It->strLineNumber + "\n";
                    strResult += "Expected:\n" + It->strExpected + "\n";
                    strResult += "Actual:\n" + It->strActual + "\n";
                }
            }
            return strResult;
        }

    protected:

        void vColourize(std::string &strExpected, std::string &strActual, const std::string &strE, const std::string &strA)
        {
            size_t ** pC = pLCSLength(strE, strA);

            if(pC != NULL)
            {
                vGenerateDiff(pC, strE, strA, strE.size(), strA.size(), strExpected, strActual);
                for(size_t i = 0; i < strE.size() + 1; ++i)
                {
                    delete [] pC[i];
                }
                delete [] pC;
            }
        }

        // -----------------------------------------------------------------------------------------
        /// Compute the longest common subsequence between X and Y
        /// On return, C will contain the LCS table.
        /// C[m][n] will contain the length of the longest common subsequence.
        /// HTTP://en.wikipedia.org/wiki/Longest_common_subsequence_problem
        /// \param X --> the expected value
        /// \param Y --> the actual   value
        //
        /// \return C[m][n] will contain the length of the longest common subsequence
        // -----------------------------------------------------------------------------------------
        template<typename T> size_t ** pLCSLength(const T &X, const T &Y)
        {
            const size_t m(X.size());
            const size_t n(Y.size());

            size_t **C = NULL;
            try
            {
                C = new size_t*[m + 1];
            }
            catch(std::bad_alloc)
            {
                return NULL;
            }
            try
            {
                for(size_t i = 0; i < m + 1; ++i)
                {
                    C[i] = new size_t[n + 1];
                }
            }
            catch(std::bad_alloc)
            {
                delete [] C;
                return NULL;
            }

            for (size_t i = 0; i <= m; ++i)
            {
                C[i][0] = 0;
            }

            for (size_t j = 0; j <= n; ++j)
            {
                C[0][j] = 0;
            }

            for (size_t i = 0; i < m; ++i)
            {
                for (size_t j = 0; j < n; ++j)
                {
                    if (X[i] == Y[j])
                    {
                        C[i + 1][j + 1] = C[i][j] + 1;
                    }
                    else
                    {
                        C[i + 1][j + 1] = max(C[i + 1][j], C[i][j + 1]);
                    }
                }
            }
            return C;
        }

        template <typename T> void vGenerateDiff(size_t **C, const T & X, const T &Y, const size_t &i, const size_t &j, T & XOut, T &YOut)
        {
            if (i > 0 && j > 0 && X[i] == Y[j])
            {
                vGenerateDiff(C, X, Y, i - 1, j - 1, XOut, YOut);

                XOut += m_strColorTags[GREEN_COLOR_BEG]; // green color
                XOut += X[i];
                XOut += m_strColorTags[COLOR_END]; // default color

                YOut += m_strColorTags[GREEN_COLOR_BEG]; // green color
                YOut += Y[j];
                YOut += m_strColorTags[COLOR_END]; // default color
            }
            else if (j > 0 && (i == 0 || C[i][j - 1] >= C[i - 1][j]))
            {
                vGenerateDiff(C, X, Y, i, j - 1, XOut, YOut);

                if(Y[j] == ' ')
                {
                    YOut += m_strColorTags[RED_COLOR_REVERSE_BEG]; // reverse red color
                }
                else
                {
                    YOut += m_strColorTags[RED_COLOR_BEG]; // red color
                }
                YOut += Y[j];
                YOut += m_strColorTags[COLOR_END]; // default color
            }
            else if (i > 0 && (j == 0 || C[i][j - 1] <= C[i - 1][j]))
            {
                vGenerateDiff(C, X, Y, i - 1, j, XOut, YOut);
                XOut += X[i];
            }
        }

        struct SAssertResults
        {
            std::string strExpected;
            std::string strActual;
            std::string strLineNumber;
            std::string strFileName;
        };

        // this vector of pairs stores the expected and the actual results
        std::vector< SAssertResults > m_Asserts;

        enum EColorCodes
        {
            RED_COLOR_BEG          = 0
                                     , GREEN_COLOR_BEG
            , RED_COLOR_REVERSE_BEG
            , GREEN_COLOR_REVERSE_BEG
            , COLOR_END
            , NUMBER_OF_COLORS

        };
        /// A string array to store color tags
        std::string m_strColorTags[NUMBER_OF_COLORS];
};



class TestFixture
{
    private:
        static std::ostringstream errmsg;
        static simple_testsuite_assert_results m_SCAssertResultRecorder;
        static size_t countTests;
        static size_t fails_counter;
        static size_t assert_counter;
        static size_t todos_counter;
        static size_t fails_counter_backup;

    public:
        std::string classname;
    protected:
        std::string testToRun;
        bool bIsActivated;
        size_t m_LengthOfLinePtr;
        std::string m_strCurrentClassName;
        static size_t m_assertCount;

        /// \brief stop on first error [default = false]
        bool m_bStopOnError;

        // --------------------------------------------------
        /// Generate a random number of type T
        /// \return <-- a random number
        // --------------------------------------------------
        template <typename T> T GetRandomNumber(void)
        {
            // cppcheck-suppress obsoleteFunctionsrand_r
            return (static_cast<T>(rand_r(&m_uiRandomSeed)));
        }

        //virtual void prepare() = 0;
        virtual void run()     = 0;
        //virtual void cleanup() = 0;

        bool runTest(const char testname[]);

        void vAssert(const char *filename, unsigned int linenr, bool condition);

        void assertEquals(const char * const filename, unsigned int linenr, const std::string &expected, const std::string &actual, const std::string &msg = "");

        // the vars expected and actual need to be of type double, in order to avoid overflow of unsigned int
        // e.g: ASSERT_EQUALS(-100.0, MathLib::toDoubleNumber("-1.0E+2")); would not work without this.
        void assertEquals(const char *filename, unsigned int linenr, double expected, double actual, const std::string &msg = "");
        void assertEquals_size_t(const char * const filename, unsigned int linenr, size_t expected, size_t actual, const std::string &msg = "");
        void assertEquals_long_int(const char * const filename, unsigned int linenr, long int expected, long int actual, const std::string &msg = "");
        void todoAssertEquals(const char * const filename, unsigned int linenr, const std::string &expected, const std::string &actual);
        void todoAssertEquals(const char * const filename, unsigned int linenr, unsigned int expected, unsigned int actual);
        void assertThrowFail(const char *const filename, unsigned int linenr);

        void vStopOnError(const bool &bStopOnError)
        {
            m_bStopOnError = bStopOnError;
        }

    public:
        void reportOut(const std::string &outmsg) const;
        //    virtual void reportErr(const ErrorLogger::ErrorMessage &msg);
        void reportStatus() const;
        static void printFinalReport(void);
        void run(const std::string &str);
        static std::string strWriteStr(const std::string &str);

        /*! \brief Execute an external tool (e.g. GCC) and capture its output.
         *
         * \param [in] toolName     The name of the tool.
         * \param [in] toolOptions  The tools options.
         * \param [in] fileNames    The file names, the tool needs as input. In case no file name is required, provide an empty string vector.
         * \param [out] capturedOutput      The output of the tool.
         * \param [in] captureFromStream 1 = stdout, 2 stderr or any other number for stdout and stderr
         *
         * \return False in case the tool cannot be executed or an internal error is produced.
         *         True in case the tool executed successfully.
         */
        static bool executeExternalTool(const std::string &toolName, const std::string &toolOptions, const std::vector<std::string> &fileNames, std::string &capturedOutput, size_t captureFromStream = 2);

        explicit TestFixture(const std::string &_name);
        virtual ~TestFixture(void);

        // ---------------------------------------
        /// Print the registered test to std::cout
        // ---------------------------------------
        static void printTests(void);

        // ---------------------------------------
        /// Get a list of registered tests
        /// \return <-- a list of names
        // ---------------------------------------
        static const std::list<std::string> strGetListOfTests(void);

        // -------------------------------------------------------------
        /// Exclude a specific test from the test chain.
        //
        /// \param strNameOfTest --> the name of the test to exclude
        // -------------------------------------------------------------
        static void vExcludeTest(const std::string &strNameOfTest);

        static size_t runTests(const char cmd[]);

        static bool bRevertOrder;

        static void vSetConfiguration(const simple_testsuite_settings &Settings)
        {
            m_Settings = Settings;
        }

        static simple_testsuite_settings m_Settings;
        /// \brief a variable to store the random seed
        unsigned int m_uiRandomSeed;
};

#define START_LISTEN_COUT \
    std::streambuf *m_pBackupCoutStream=NULL;\
    m_pBackupCoutStream = std::cout.rdbuf();\
    std::cout.rdbuf(output.rdbuf());\
     

#define END_LISTEN_COUT \
    std::cout.rdbuf(m_pBackupCoutStream);\
     

#define START_LISTEN_CERR \
    std::streambuf *m_pBackupCerrStream=NULL;\
    m_pBackupCerrStream = std::cerr.rdbuf();\
    std::cerr.rdbuf(output.rdbuf());\
     

#define END_LISTEN_CERR \
    std::cerr.rdbuf(m_pBackupCerrStream);\
     
#define START_LISTEN_ALL\
    START_LISTEN_COUT\
    START_LISTEN_CERR

#define END_LISTEN_ALL\
    END_LISTEN_COUT\
    END_LISTEN_CERR

#define CLEAR_COUT_STREAM {output.str("");}
#define CLEAR_CERR_STREAM {errout.str("");}

#define TEST_CASE( NAME )  { if ( runTest(#NAME) ) {START_LISTEN_ALL  NAME(); END_LISTEN_ALL reportStatus();} }
#define ASSERT( CONDITION )  vAssert(__FILE__, __LINE__, CONDITION)
#define ASSERT_EQUALS( EXPECTED , ACTUAL ) { assertEquals(__FILE__, __LINE__, EXPECTED, ACTUAL); ++m_assertCount; }
#define ASSERT_EQUALS_SIZE_T( EXPECTED , ACTUAL ) { assertEquals_size_t(__FILE__, __LINE__, EXPECTED, ACTUAL); ++m_assertCount; }
#define ASSERT_EQUALS_LONG_INT( EXPECTED , ACTUAL ) { assertEquals_long_int(__FILE__, __LINE__, EXPECTED, ACTUAL); ++m_assertCount; }
/* @todo extend by
TEST_ASSERT_EQUAL_INT(expected, actual)
TEST_ASSERT_EQUAL_INT8(expected, actual)
TEST_ASSERT_EQUAL_INT16(expected, actual)
TEST_ASSERT_EQUAL_INT32(expected, actual)
TEST_ASSERT_EQUAL_INT64(expected, actual)
TEST_ASSERT_EQUAL(expected, actual)
TEST_ASSERT_NOT_EQUAL(expected, actual)
TEST_ASSERT_EQUAL_UINT(expected, actual)
TEST_ASSERT_EQUAL_UINT8(expected, actual)
TEST_ASSERT_EQUAL_UINT16(expected, actual)
TEST_ASSERT_EQUAL_UINT32(expected, actual)
TEST_ASSERT_EQUAL_UINT64(expected, actual)
TEST_ASSERT_EQUAL_HEX(expected, actual)
TEST_ASSERT_EQUAL_HEX8(expected, actual)
TEST_ASSERT_EQUAL_HEX16(expected, actual)
TEST_ASSERT_EQUAL_HEX32(expected, actual)
TEST_ASSERT_EQUAL_HEX64(expected, actual)
TEST_ASSERT_BITS(mask, expected, actual)
TEST_ASSERT_BITS_HIGH(mask, actual)
TEST_ASSERT_BITS_LOW(mask, actual)
TEST_ASSERT_BIT_HIGH(bit, actual)
TEST_ASSERT_BIT_LOW(bit, actual)
*/

#define ASSERT_EQUALS_MSG( EXPECTED , ACTUAL, MSG )  assertEquals(__FILE__, __LINE__, EXPECTED, ACTUAL, MSG)
#define ASSERT_THROW( CMD, EXCEPTION ) try { CMD ; assertThrowFail(__FILE__, __LINE__); } catch (EXCEPTION &) { } catch (...) { assertThrowFail(__FILE__, __LINE__); }
#define TODO_ASSERT_EQUALS( EXPECTED , ACTUAL ) todoAssertEquals(__FILE__, __LINE__, EXPECTED, ACTUAL)
#define REGISTER_TEST( CLASSNAME ) namespace { CLASSNAME instance; }

#ifndef __EXTERN_STREAMS__
#define __EXTERN_STREAMS__
extern std::ostringstream errout;
extern std::ostringstream output;
#endif //__EXTERN_STREAMS__


#endif // SIMPLE_TESTSUITE_H

